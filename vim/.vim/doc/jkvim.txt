*jkvim.txt*                 Jivko's Vim Reference
*jkvim*

                   _ _       _                    _                          ~
                 (_|_)_   _| | _____      __   _(_)_ __ ___                  ~
                 | | \ \ / / |/ / _ \ ____\ \ / / | '_ ` _ \                 ~
                 | | |\ V /|   < (_) |_____\ V /| | | | | | |                ~
                _/ |_| \_/ |_|\_\___/       \_/ |_|_| |_| |_|                ~
               |__/                                                          ~
                                                                             ~
==============================================================================
CONTENTS                                                  *jkvim-contents*

   01. Intro ............................................. |jkvim-summary|
   02. Commands ......................................... |jkvim-commands|
   03. Plugins ........................................... |jkvim-plugins|

==============================================================================
SUMMARY                                                    *jkvim-summary*

Cheat-sheet for all vim customizations.

==============================================================================
CODE PRODUCTIVITY                                         *jkvim-code-productivity*

Plugins handling these coding aspects:
Languages, filetypes, syntax: sheerun/vim-polyglot
Coding styles: vim-editorconfig
Completion: Shougo/deoplete.nvim
Formatting: Chiel92/vim-autoformat
Linting: w0rp/ale
Searching: junegunn/fzf, junegunn/fzf.vim, mileszs/ack.vim
Symbols: majutsushi/tagbar
Sessions: xolox/vim-session
Snippets: msanders/snipmate.vim

==============================================================================
COMMANDS                                                  *jkvim-commands*

Lists frequently used commands and shortcuts.
NOTE: custom shortcuts are shown as surrounded with parentheses.
Leader key: space ( )

=== Misc
:h :help some_topic
:q :quit Ctrl-W_q - quits current window
( ss) - strip trailing whitespace
C-o - move back the jump stack
C-i - move forward in jump stack (assumes previous moves back)
( ci) - toggles comment state (requires nerdcommenter)
:echo mapleader - prints current leader key
:map :Maps - shows all mappings

== Edit
r<some_char> - replaces the current character with some_char
u - undo
C-r - redo
C-w - (insert mode) erases word
C-u - (insert mode) erases text from cursor to beginning of line. Also works in the command line.
~ - inverts casing of current character
~ (visual mode) - inverts casing of current selection.
U (visual mode) - uppercases the current selection.
u (visual mode) - lowercases the current selection.

=== Help
:h(elp) command - opens help for command. When command is incomplete, <Tab> cycles through and C-d lists possible command completions.
When in help pages, C-] jumps to subjects between |bars| and C-t jumps back. Use :q to quit.

=== Variables
:set                - shows vars different from defaults
:set all            - shows all values
:set foo?           - shows the value of foo
:set foo+=opt       - add opt to the value w/o changing others
:set foo-=opt       - remove opt from value
:set foo&           - reset foo to default value
:setlocal foo       - sets foo only in the current buffer
:verbose set foo?   - tells where foo was last set

=== Indenting
>> - indent line. Repeat with .
visual < or > - indent selected text in or out. Repeat with .

=== Text selection, copy & paste
:v - visual mode, char selection
:V - line selection
:C-v - block selection
d - cut
y - copy
p - paste before current char
P - paste after current char
On selected test: :s/match/replace/, or :center, or !sort, etc.

=== Buffers/Files
:e :edit                    - open file for editing
:w :write ( w)              - write buffer to file
( W)                        - save file as root
:bn :bnext (]b) ( bn)       - next buffer
:bp :bprevious ([b) ( bp)   - previous buffer
:bd ( bd)                   - close buffer
:ls                         - show current buffers

=== Windows - Ctrl-W
:new (C-w n)         - create new window and starts editing empty file
:c :close (C-w q)    - close current window
:sp :split (C-w s)   - split current window in two, horizontally
:vs :vsplit (C-w v)  - split current window in two, vertically
:split <file>        - split current window with horizontal bar, opens <file> in new window
:vsplit <file>       - split current window with vertical bar, opens <file> in new window
:b 2                 - open buffer #2 in current window
:hide                - close current window
:only                - only keep current window open
C-w arrows           - move between windows
C-w h/j/k/l          - move between windows
C-w w                - toggle between windows
C-w +/-              - increase/decrease window with 1 line (numbers work too - for multiple lines size change)
C-w _                - maximize current window
C-w =                - make all windows same size
( cd)                - Switch CWD to the directory of the open buffer

=== Tabs
:tabnew ( tn)
:tabclose ( tc)
:tabedit ( te)
:tabp (F11) - previous tab
:tabn (F12) - next tab

=== Sessions
:mksession <session_filename> - store current session to a file
:source <session_filename> - open stored session
:SaveSession <session_name> - save current session (requires vim-session)
:OpenSession <session_name> - open stored session (requires vim-session)
:RestartVim - save current session, restart Vim, restore session
vim --servername some_session_name - this can be used to automatically load/save sessions

=== Registers
:reg :registers - see registers content
:h registers
Access a register with double-quote ".
Copy to a named register: ", then the name of the register (a), then y. Usage: "ay
Paste from a named register - same format as the copy: "ap
Copying/deleting/pasting from a "q" register: "qy / "qd / "qp
There are ten types of registers:
1. The unnamed register ""
    Vim fills this register with text deleted with the "d", "c", "s", "x" commands or copied with the yank "y" command, regardless of whether or not a specific register was used. This is like the unnamed register is pointing to the last used register.
    Note: this is the only register that is always modified on text copy/deletion - even if the operation uses a specific register (e.g. "xy)
    In contrast, the other registers below are not used if the text operation involves specific register.
2. 10 numbered registers "0 to "9
    Vim fills these registers with text from yank and delete commands.
    Numbered register 0 contains the text from the most recent yank command.
    Numbered register 1 contains the text deleted by the most recent delete or change command.
    With each successive deletion or change, Vim shifts the previous contents of register 1 into register 2, 2 into 3, and so forth.
3. The small delete register "-
    This register contains text from commands that delete less than one line,
4. 26 named registers "a to "z or "A to "Z
    Vim fills these registers only when you say so. Specify them as lowercase letters to replace their previous contents or as uppercase letters to append to their previous contents.
5. three read-only registers ":, "., "%
    ". Contains the last inserted text
    "% Contains the name of the current file.
    ": Contains the most recent executed command-line.
6. alternate buffer register "#
    Contains the name of the alternate file for the current window.
7. the expression register "=
    This is not really a register that stores text, but is a way to use an expression in commands which use a register.
8. The selection and drop registers "*, "+ and "~
    Use these registers for storing and retrieving the selected text for the GUI.
9. The black hole register "_
    When writing to this register, nothing happens. This can be used to delete text without affecting the normal registers. When reading from this register, nothing is returned.
10. Last search pattern register "/
    Contains the most recent search-pattern.

=== Macros
qk  - starts recording commands into register 'k'. Enter commands, then q to stop recording.
@k  - execute macro in register k
5@k  - execute 5 times macro in register k
@@  - repeat last executed macro
5@@ - repeat last macro 5 times
"kp - print macro k
"kd - replace register k with what cursor is on

=== Linting, syntax-coloring, and auto-formatting
:Autoformat ( f) - from vim-autoformat, auto-formats text, according to the filetype, indent settings, and formatters
gg=G - re-indents the whole file, by: going to beginning of file (gg), indent (=), go to end of file (G)
== - indents selected section
:retab - re-tabs the whole file
:RemoveTrailingSpaces - remove trailing whitespaces

=== Makefile
:make - runs make (assumes makefile exists)
:set makeprg - change what :make does

=== Visual mode
v - in visual mode, this, as pressed multiple times, continues to expand the selection
C-v - shrink previously expanded selection

=== Fuzzy text finders
:FZF ( o) - list of files in in current directory and subs. Use these keys to open the new file:
    - enter - current window
    - C-t - new tab
    - C-x - horizontal split
    - C-v - vertical split

=== Search & Replace
/
n - next match
N - previous match
:%s/SSS/RRR/g - search SSS and replace it with RRR
:%s/SSS/RRR/gc - Change each 'SSS' to 'RRR', but ask for confirmation first.
(*) (#) - search for current selection and highlight matches
g* - search for partial match for current selection and highlight matches
<space><enter> - un-highlight search highlights
do /, type the searched string, <CR>, cgn, type replacement, . to repeat the replacement consecutively through all selections; or n to skip a selection
Instead of searching for the string - use * to search for the current word under the cursor, then continue with cgn
Note: cgN, dgn, dgN work appropriately as well.
f<some_character> - looks for some_character in the same line after the cursor
:Ag [pattern] - search recursively files for text pattern (requires fzf-vim)
C-n - multiple cursors selection (requires vim-multiple-cursors). Change text by C-n, c, text
[I - show lines with matching word under cursor

=== Marks
:h mark-motions
:marks - show all marks
:marks aB - show marks "a" and "B"
:Marks - show/search all marks (requires fzf-vim)
ma - store the current position in the "a" mark. Lowercase a-z letters are local marks - they work within a file. Upper-case A-Z letters are global marks - they work across multiple files
`a - go to the line and column for mark "a".
'a - go to the beginning of the line where mark "a" is set
]' - jump to next line with lowercase mark
[' - jump to previous line with a lowercase mark
]` - jump to next lowercase mark
[` - jump to previous lowercase mark
'' - jump back (to line in current buffer where jumped from)
`` - jump back (to position in current buffer where jumped from)
`. - moves the cursor to the line and column where the last edit was made
'. - moves the cursor to the line where the last edit was made
`" - jump to position where last exited current buffer
`0 - jump to position in last file edited (when exited Vim)
:delmarks a - delete mark a
:delmarks a-d - delete marks a, b, c, d
:delmarks abxy - delete marks a, b, x, y
:delmarks aA - delete marks a, A
:delmarks! - delete all lowercase marks for the current buffer (a-z)
vim-signature commands:
  mx           Toggle mark 'x' and display it in the leftmost column
  dmx          Remove mark 'x' where x is a-zA-Z
  m,           Place the next available mark
  m.           If no mark on line, place the next available mark. Otherwise, remove (first) existing mark.
  m-           Delete all marks from the current line

=== Tags
:tag <ttt> - search for the ttt tag
:CtrlPTag ( t) - search tags (requires CtrlP)
:Tags - show tags (requires fzf-vim)
:BTags - show tags in the current buffer (requires fzf-vim)
F3 - toggles Tagbar
:tnext :tn ( ]t) - go to the next definition for the last searched tag
:tprevious :tp ( [p) - go to the previous definition for the last searched tag
:tfirst :tf ( [T) - go to the first definition for the last searched tag
:tlast :tl ( ]T) - go to the last definition for the last searched tag
:tselect :ts ( ts) - list all definitions for the last searched tag
C-] - Jump to definition for text under the cursor
C-t - Jump back from definition
C-w} :ptag - Preview definition for text under the cursor
g] - See all definitions for text under the cursor
:pclose - close Preview window

=== Quickfix & Location windows
In Vim the quickfix commands are used to find a list of positions in files - the idea being to speedup the edit-compile-edit cycle.
Various commands can produce quickfix lists (`:vimgrep`, `:grep`, `:helpgrep`, `:make`). The Quickfix lists are global for all buffers.
A location list is a window-local quickfix list. You get one after commands like `:lvimgrep`, `:lgrep`, `:lhelpgrep`, `:lmake`, etc., which create a location list instead of a quickfix list. A location list is associated with one-and-only window.
:cnext ( ]q) - next Quickfix entry
:cprevious ( [q) - previous Quickfix entry
:cfirst ( [Q) - first Quickfix entry
:clast ( ]Q) - last Quickfix entry
:copen ( qo) - open Quickfix window
:cclose ( qc) - close Quickfix window
:cw - toggles Quickfix window
:lnext ( ]l) - next Locations entry
:lprevious ( [l) - previous Locations entry
:lfirst ( [L) - first Locations entry
:llast ( ]L) - last Locations entry
:lopen ( lo) - open Locations window
:lclose ( lc) - close Locations window

=== Key mappings
:map,nmap,vmap,imap - show key mappings for normal,visual,insert mode
:Unite mapping - show all key mappings (requires Unite)

=== Folding
:zc ( zc) - close a fold
:zo ( zo) - open a fold
( za) - toggle a fold
( zC) ( zO) ( zA) - same as above but operating on all folding levels
( zr) - open one more level of folds throughout the buffer
( zR) - open all folds
( zm) - close one more lovel of folds throughout the buffer
( zM) - close all folds
( zx) - fixup current fold if it is broken for some reason
( zX) - fixup all folds

=== Syntax / colors
:colorscheme <scheme> - set color scheme
:Colors - set color scheme (requires fzf)
:syntax on/off - turn on/off syntax highlighting
:syntax list - list commands for current filetype
:set syntax=sh - force desired syntax coloring
:set filetype=sh - set file type (bash in the example)
:setf sh - set file type (bash in the example)

=== History - commands and key bindings for removed plugins
--- Linting, syntax-coloring, and auto-formatting
:Neomake ( mk) - maker/linter
--- Fuzzy text finders
<C-p> - CtrlP
<C-l> - Unite with the following sources: file_rec buffer


==============================================================================
PLUGINS                                                    *jkvim-plugins*

Describes used plugins and their behaviors / shortcuts


=== Plugin managers

=== Vundle
:h vundle
:PluginInstall - installs plugins configured in the .vimrc
:PluginInstall plugin_1 plugin_2 - installs specific plugins
:PluginInstall! :PluginUpdate - updates plugins
:PluginSearch foo - searches for foo in Vim Scripts (http://vim-scripts.org/vim/scripts.html)
:PluginList - Displays a list of installed bundles.

=== VimPlug
:PlugInstall [name ...] [#threads]   - Install plugins
:PlugUpdate [name ...] [#threads]    - Install or update plugins
:PlugClean[!]   - Remove unused directories (bang version will clean without prompt)
:PlugUpgrade   - Upgrade vim-plug itself
:PlugStatus   - Check the status of plugins
:PlugDiff   - Examine changes from the previous update and the pending changes
:PlugSnapshot[!] [output path]   - Generate script for restoring the current snapshot of the plugins


=== UI

=== vim-startify
Start screen with MRUs, sessions, bookmarks, etc.
:h startify-options
:h startify-commands
:Startify - shows the startup screen again
:SLoad    - load a session
:SSave    - save a session
:SDelete  - delete a session

=== vimux
tmux integration, runs shell commands
:help vimux

=== vim-airline
status line
:h airline
:AirlineToggle
:AirlineRefresh

=== vim-gitgutter
git diff in the gutter and stages/reverts hunks
Features:
* Shows signs for added, modified, and removed lines.
* Ensures signs are always as up to date as possible (but without running more than necessary).
* Quick jumping between blocks of changed lines ("hunks").
* Stage/revert/preview individual hunks.
* Optional line highlighting.
* Fully customisable (signs, sign column, line highlights, mappings, extra git-diff arguments, etc).
* Can be toggled on/off.
* Preserves signs from other plugins.
* Easy to integrate diff stats into status line; built-in integration with vim-airline.
Help:
:h gitgutter
:h GitGutterCommands
Usage:
:GitGutterDisable :GitGutterEnable :GitGutterToggle
:GitGutterSignsEnable :GitGutterSignsDisable :GitGutterSignsToggle
:GitGutterLineHighlightsEnable :GitGutterLineHighlightsDisable :GitGutterLineHighlightsToggle ( ht)
:GitGutterNextHunk (]c) - jump to next change
:GitGutterPrevHunk ([c) - jump to next change
:GitGutterStageHunk ( hs) - stage the hunk
:GitGutterRevertHunk ( hr) - revert the hunk
:GitGutterPreviewHunk ( hp) - preview hunk's changes

=== vim-fugitive
Git wrapper
Custom mappings:
:Gstatus ( gs)
:Gcommit ( gc)
( ga) - adds everything and commits
:Gblame ( gb)
More help:
:h fugitive
:h Gstatus - for more keys during the status message

=== indent-guides
Displays indent levels
:IndentGuidesToggle ( ig) - toggles the indent guides on and off
:h indent-guide


=== Editing

=== snipmate.vim
snippets mgmt for various languages
:h snipMate

=== vim-table-mode
tables creation
:h table-mode.txt

=== tabular
text alignment
:h tabular
:Tabularize

=== ZoomWin
Zoom in/out of windows (toggle between one window and multi-window)
:ZoomWin <c-w>o : toggles the current window zooms into a full screen or the original set of windows

=== vim-multiple-cursors
Multiple selections
:h multiple-cursors-usage
Mappings:
C-n - pressing it selects the current word. Pressing it again finds the next matching occurence and selects it.
Note: If selection already exists prior to pressing C-n for the first time, it will be used instead.
C-p - removes the current virtual cursor and go back to the previous one - useful for uno-ing actions.
C-x - remove the current virtual cursor and skip to the next one.

=== EasyMotion
Speedy moving within the page text
:h easymotion
Example usage:
    Start with:
        <cursor>Lorem ipsum dolor sit amet.
    Type <Leader><Leader>w to trigger the word motion w. When the motion is triggered, the text is updated (no braces are actually added, the text is highlighted in red by default):
        <cursor>Lorem {a}psum {b}olor {c}it {d}met.
    Press c to jump to the beginning of the word "sit":
        Lorem ipsum dolor <cursor>sit amet.
    Similarly, if you're looking for an "o", you can use the f motion. Type <Leader><Leader>fo, and all "o" characters are highlighted:
        <cursor>L{a}rem ipsum d{b}l{c}r sit amet.
    Press b to jump to the second "o":
        Lorem ipsum d<cursor>olor sit amet.
Mappings:
    <Leader><Leader>f{char} | Find {char} to the right
    <Leader><Leader>F{char} | Find {char} to the left
    <Leader><Leader>s{char} | Find(Search) {char} forward and backward.
    <Leader><Leader>t{char} | Till before the {char} to the right
    <Leader><Leader>T{char} | Till after the {char} to the left
    <Leader><Leader>w       | Beginning of word forward
    <Leader><Leader>W       | Beginning of WORD forward
    <Leader><Leader>b       | Beginning of word backward
    <Leader><Leader>B       | Beginning of WORD backward
    <Leader><Leader>e       | End of word forward
    <Leader><Leader>E       | End of WORD forward
    <Leader><Leader>ge      | End of word backward.
    <Leader><Leader>gE      | End of WORD backward.
    <Leader><Leader>j       | Line downward
    <Leader><Leader>k       | Line upward
    <Leader><Leader>n       | Jump to latest "/" or "?" forward
    <Leader><Leader>N       | Jump to latest "/" or "?" backward

=== Surround
Surroundings: parentheses, brackets, quotes, XML tags, and more
:h surround
Examples. An asterisk (*) is used to denote the cursor position.
  Old text                  Command     New text
  "Hello *world!"           ds"         Hello world!
  [123+4*56]/2              cs])        (123+456)/2
  "Look ma, I'm *HTML!"     cs"<q>      <q>Look ma, I'm HTML!</q>
  if *x>3 {                 ysW(        if ( x>3 ) {
  my $str = *whee!;         vllllS'     my $str = 'whee!';
ds - delete surrounding
  Old text                  Command     New text ~
  "Hello *world!"           ds"         Hello world!
  (123+4*56)/2              ds)         123+456/2
  <div>Yo!*</div>           dst         Yo!
cs - change surrounding
  Old text                  Command     New text
  "Hello *world!"           cs"'        'Hello world!'
  "Hello *world!"           cs"<q>      <q>Hello world!</q>
  (123+4*56)/2              cs)]        [123+456]/2
  (123+4*56)/2              cs)[        [ 123+456 ]/2
  <div>Yo!*</div>           cst<p>      <p>Yo!</p>
ys - takes a valid Vim motion or text object as the first object, and wraps it using the second argument as with |cs|.
  Old text                  Command     New text
  Hello w*orld!             ysiw)       Hello (world)!
yss - operates on the current line, ignoring leading whitespace.
  Old text                  Command     New text
  Hello w*orld!             yssB        {Hello world!}
S - In visual mode, a simple "S" with an argument wraps the selection.

=== Repeat
Enable repeating supported plugin maps with "."
Supported plugins:
* surround.vim
* speeddating.vim
* abolish.vim
* unimpaired.vim
* commentary.vim
* vim-easyclip
Adding support to a plugin is generally as simple as the following command at the end of your map functions.
  silent! call repeat#set("\<Plug>MyWonderfulMap", v:count)

=== vim-unimpaired
This plugin provides several pairs of bracket maps.
:h unimpaired
The following maps all correspond to normal mode commands.If [count] is given, it becomes an argument to the command.
Mappings:
[a     :previous
]a     :next
[A     :first
]A     :last
[b     :bprevious
]b     :bnext
[B     :bfirst
]B     :blast
[l     :lprevious
]l     :lnext
[L     :lfirst
]L     :llast
[<C-L> :lpfile
]<C-L> :lnfile
[q     :cprevious
]q     :cnext
[Q     :cfirst
]Q     :clast
[<C-Q> :cpfile (Note that <C-Q> only works in a terminal if you disable
]<C-Q> :cnfile flow control: stty -ixon)
[t     :tprevious
]t     :tnext
[T     :tfirst
]T     :tlast
[n     Go to the previous SCM conflict marker or diff/patch hunk
]n     Go to the next SCM conflict marker or diff/patch hunk
[<Space> Add blank line/s above the cursor.
]<Space> Add blank line/s below the cursor.
[e     Exchange the current line with line/s above it.
]e     Exchange the current line with line/s below it.

=== Emmet
Emmet is an editor plugin for high-speed HTML, XML, XSL (or any other
structured code format) coding and editing. The core of this plugin is a
powerful abbreviation engine which allows you to expand expressions,
similar to CSS selectors, into HTML code:   div#page>div.logo+ul#navigation>li*5>a
Note: too much to list, just go to the help
:h emmet

=== EditorConfig
EditorConfig plugin for vim
:h EditorConfig
Commands:
:EditorConfigReload
Settings: see help

=== Deoplete
Provides asynchronous keyword completion system in the
current buffer
:h deoplete
Settings:
g:deoplete#enable_at_startup = 1
g:deoplete#enable_smart_case = 1
... manu more, look at the help


=== Buffers/files

=== nerdtree
File tree explorer
:h NERDTree
:h NERDTreeBookmarkCommands
:h NERDTreeMappings
:NERDTreeToggle (F2) ( nt) - toggles the explorer on/off
:NERDTreeFind ( ntf) - opens the explorer with focus on the current file
:NERDTree /home/Jivko/dotfiles
:NERDTree foo - roots the tree at foo (foo is the name of a bookmark)
:NERDTreeFind - Find the current file in the tree
:NERDTreeCWD - Change tree root to current directory
Bookmarks:
:Bookmark <name> - bookmark the current node as <name>
:OpenBookmark <bookmark> - opens the bookmark - it must be a file
:ClearBookmarks [<bookmarks>]
:ClearAllBookmarks
Mappings:
:NERDTreeMapActivateNode (o,<cr>,mouse-click) - Open files, directories and bookmarks
go - Open selected file, but leave cursor in the NERDTree
:NERDTreeMapOpenInTab (t) - Open selected node/bookmark in a new tab
:NERDTreeMapOpenInTabSilent (T) - Same as 't' but keep the focus on the current tab
:NERDTreeMapOpenSplit (i) - Open selected file in a split window
(gi) - Same as i, but leave the cursor on the NERDTree
:NERDTreeMapOpenVSplit (s) - Open selected file in a new vsplit
(gs) - Same as s, but leave the cursor on the NERDTree
:NERDTreeMapOpenRecursively (O) - Recursively open the selected directory
:NERDTreeMapCloseDir (x) - Close the current nodes parent
:NERDTreeMapCloseChildren (X) - Recursively close all children of the current node
:NERDTreeMapDeleteBookmark (D) - Delete the current bookmark
:NERDTreeMapJumpRoot (P) - Jump to the root node
:NERDTreeMapJumpParent (p) - Jump to current nodes parent
:NERDTreeMapJumpFirstChild (K) - Jump up inside directories at the current tree depth
:NERDTreeMapJumpLastChild (J) - Jump down inside directories at the current tree depth
:NERDTreeMapJumpNextSibling <C-j>.-.Jump down to the next sibling of the current directory
:NERDTreeMapJumpPrevSibling <C-k>.-.Jump up to the previous sibling of the current directory
:NERDTreeMapChangeRoot (C) - Change the tree root to the selected dir
:NERDTreeMapUpdir (u) - Move the tree root up one directory
:NERDTreeMapUpdirKeepOpen (U) - Same as 'u' except the old root node is left open
:NERDTreeMapRefresh (r) - Recursively refresh the current directory
:NERDTreeMapRefreshRoot (R) - Recursively refresh the current root
:NERDTreeMapMenu (m) - Display the NERD tree menu - copy/move directories/files
:NERDTreeMapChdir (cd) - Change the CWD to the dir of the selected node
:NERDTreeMapCWD (CD) - Change tree root to the CWD
:NERDTreeMapToggleHidden (I) - Toggle whether hidden files displayed
:NERDTreeMapToggleFilters (f) - Toggle whether the file filters are used
:NERDTreeMapToggleFiles (F) - Toggle whether files are displayed
:NERDTreeMapToggleBookmarks (B) - Toggle whether the bookmark table is displayed
:NERDTreeMapQuit (q) - Close the NERDTree window
:NERDTreeMapToggleZoom (A) - Zoom (maximize/minimize) the NERDTree window
:NERDTreeMapHelp (?) - Toggle the display of the quick help

=== nerdtree-git-plugin
show git status in NerdTree
Use this variable to change symbols:
let g:NERDTreeIndicatorMapCustom = {
    \ "Modified"  : "✹",
    \ "Staged"    : "✚",
    \ "Untracked" : "✭",
    \ "Renamed"   : "➜",
    \ "Unmerged"  : "═",
    \ "Deleted"   : "✖",
    \ "Dirty"     : "✗",
    \ "Clean"     : "✔︎",
    \ "Unknown"   : "?"
    \ }

=== vim-scratch
Temporary scratch buffers
:Scratch  - open/edit the scratch buffer
:Sscratch - open the scratch buffer in a new split window

=== Code checking and formatting

=== Neomake
:Neomake [makers]       Run a make command with the current file as input. If
                        no makers are specified, the default makers for the
                        current |filetype| are used. See |neomake-configuration|
                        for more on makers.
:Neomake! [makers]      Run a make command with no file as input. If no makers
                        are specified, the default top-level makers will be
                        used. If no default top-level makers exist, |makeprg|
                        will be used.
:NeomakeSh {command}    Run {command} in a shell (according to 'shell'). The
                        command output will be loaded into the quickfix list
                        when the job is complete. Example: >
                        :NeomakeSh find . -name '*.pyc'
:NeomakeSh! {command}   Same as |:NeomakeSh|, but does not buffer the output.
                        Example: >
                        :NeomakeSh! while true; do date; sleep 1; done
:lopen                  opens the locations window to see the results from Neomake
:copen                  opens the quickfix window to see the results from Neomake!

=== syntastic
syntax checking
:h syntastic
:h syntastic-commands
:Errors
:SyntasticCheck
:SyntasticInfo
:SyntasticReset

=== nerdcommenter
comments mgmt
:h NERDCommenter
:h NERDComFunctionalitySummary
:h NERDComToggleComment
( cc) - comments block
( cu) - uncomments block
( cm) - uses multipart delimiters if possible - as in /* ... */
( ci) - inverts the comment state
( cl) - left-alligned comments
( cr) - right-alligned comments

=== Tagbar
Class outline viewer
:h tagbar
:h tagbar-usage
:TagbarToggle (F8)
:TagbarTogglePause - Freezes/Unfreezes the Tagbar window. Stops the contents of the window from changing when a different source file is selected.
Mappings:
:tagbar_map_help <F1>/? - Display key mapping help.
:tagbar_map_jump <cr>/<Enter> - Jump to the tag under the cursor
:tagbar_map_preview (p) - Jump to the tag under the cursor, but stay in the Tagbar window
:tagbar_map_previewwin (P) - Open the tag in a preview-window
<LeftMouse> - When on a fold icon, open or close the fold depending on the current state
<2-LeftMouse> Same as <CR>. See |g:tagbar_singleclick| if you want to use a single - instead of a double-click.
:tagbar_map_nexttag <C-N> - Go to the next top-level tag.
:tagbar_map_prevtag <C-P> - Go to the previous top-level tag.
:tagbar_map_showproto <Space> - Display the prototype of the current tag (i.e. the line defining it) in the command line.
:tagbar_map_hidenonpublic (v) - Hide tags that are declared non-public. Tags without any visibility information will still be shown.
:tagbar_map_openfold (+/zo) - Open the fold under the cursor.
:tagbar_map_closefold (-/zc) - Close the fold under the cursor or the current one if there is no fold under the cursor.
:tagbar_map_togglefold (o/za) - Toggle the fold under the cursor or the current one if there is no fold under the cursor.
:tagbar_map_openallfolds (*/zR) - Open all folds by setting foldlevel to 99.
:tagbar_map_closeallfolds (=/zM) - Close all folds by setting foldlevel to 0.
:tagbar_map_nextfold (zj) - Go to the start of the next fold, like the standard Vim |zj|.
:tagbar_map_prevfold (zk) - Go to the end of the previous fold, like the standard Vim |zk|.
:tagbar_map_togglesort (s) - Toggle sort order between name and file order.
:tagbar_map_toggleautoclose (c) - Toggle the |g:tagbar_autoclose| option.
:tagbar_map_zoomwin (x) - Toggle zooming the window.
:tagbar_map_close (q) - Close the Tagbar window.


=== Search

=== ctrlp.vim
Full path fuzzy file, buffer, mru, tag, ... finder
Basic Usage
* Run :CtrlP or :CtrlP [starting-directory] to invoke CtrlP in find file mode.
* Run :CtrlPBuffer or :CtrlPMRU to invoke CtrlP in find buffer or find MRU file mode.
* Run :CtrlPMixed to search in Files, Buffers and MRU files at the same time.
* Check :help ctrlp-commands and :help ctrlp-extensions for other commands.
Once CtrlP is open:
* Press <F5> to purge the cache for the current directory to get new files, remove deleted files and apply new ignore options.
* Press <c-f> and <c-b> to cycle between modes.
* Press <c-d> to switch to filename only search instead of full path.
* Press <c-r> to switch to regexp mode.
* Use <c-j>, <c-k> or the arrow keys to navigate the result list.
* Use <c-t> or <c-v>, <c-x> to open the selected entry in a new tab or in a new split.
* Use <c-n>, <c-p> to select the next/previous string in the prompt's history.
* Use <c-y> to create a new file and its parent directories.
* Use <c-z> to mark/unmark multiple files and <c-o> to open them.
Run :help ctrlp-mappings or submit ? in CtrlP for more mapping help.
* Submit two or more dots .. to go up the directory tree by one or multiple levels.
* End the input string with a colon : followed by a command to execute it on the opening file(s):
  - Use :25 to jump to line 25.
  - Use :diffthis when opening multiple files to run :diffthis on the first 4 files.

=== ack.vim
Plugin for text searchers such as ack, ag, rg
:h ack.txt
Commands:
:Ack[!] [options] {pattern} [{directory}]
:AckBuffer[!] [options] {pattern}
:AckFile [options] {pattern} [{directory}]
:AckHelp[!] [options] {pattern}
Mappings:
e - open file and close the quickfix window.
o - open file (same as enter).
go- preview file (open but maintain focus on ag.vim results).
t - open in a new tab.
T - open in new tab silently.
h - open in horizontal split.
H - open in horizontal split silently.
v - open in vertical split.
gv- open in vertical split silently.
q - close the quickfix window.

=== fzf-vim
fzf is a general-purpose command-line fuzzy finder. This plugin is a bundle of fzf-based commands and mappings
:h fzf
Commands:
:Files [PATH]         | Files (similar to `:FZF`)
:GFiles [OPTS]        | Git files (git ls-files)
:GFiles?              | Git files (git status)
:Buffers              | Open buffers
:Colors               | Color schemes
:Ag [PATTERN]         | {ag} search result (ALT-A to select all, ALT-D to deselect all)
:Lines [QUERY]        | Lines in loaded buffers
:BLines [QUERY]       | Lines in the current buffer
:Tags [QUERY] ( t)    | Tags in the project (`ctags -R`)
:BTags [QUERY] ( tb)  | Tags in the current buffer
:Marks                | Marks
:Windows              | Windows
:Locate PATTERN       | `locate` command output
:History              | `v:oldfiles` and open buffers
:History:             | Command history
:History/             | Search history
:Snippets             | Snippets ({UltiSnips})
:Commits              | Git commits (requires {fugitive.vim})
:BCommits             | Git commits for the current buffer
:Commands             | Commands
:Maps                 | Normal mode mappings
:Helptags             | Help tags [1]
:Filetypes            | File types

=== Unite
:h unite
:Unite sources - show all supported sources

=== vim-signature
toggle, display and navigate marks
:h signature
Commands:
  mx           Toggle mark 'x' and display it in the leftmost column
  dmx          Remove mark 'x' where x is a-zA-Z
  m,           Place the next available mark
  m.           If no mark on line, place the next available mark. Otherwise, remove (first) existing mark.
  m-           Delete all marks from the current line
  m<Space>     Delete all marks from the current buffer
  ]`           Jump to next mark
  [`           Jump to prev mark
  ]'           Jump to start of next line containing a mark
  ['           Jump to start of prev line containing a mark
  `]           Jump by alphabetical order to next mark
  `[           Jump by alphabetical order to prev mark
  ']           Jump by alphabetical order to start of next line having a mark
  '[           Jump by alphabetical order to start of prev line having a mark
  m/           Open location list and display marks from current buffer
  m[0-9]       Toggle the corresponding marker !@#$%^&*()
  m<S-[0-9]>   Remove all markers of the same type
  ]-           Jump to next line having a marker of the same type
  [-           Jump to prev line having a marker of the same type
  ]=           Jump to next line having a marker of any type
  [=           Jump to prev line having a marker of any type
  m?           Open location list and display markers from current buffer
  m<BS>        Remove all markers

=== vim-autoformat
Provide easy code formatting in Vim by integrating existing code formatters.
:Autoformat - auto-formats the entire file. If no suitable formatter is present, file is re-indented instead.
Check out https://github.com/Chiel92/vim-autoformat for list of format programs.
Formatters:
js-beautify for Javascript and JSON. It can be installed by running npm install -g js-beautify. Note that nodejs is needed for this to work. The python version version is also supported by default, which does not need nodejs to run. Here is the link to the repository: https://github.com/einars/js-beautify.
JSCS for Javascript. http://jscs.info/
standard for Javascript. It can be installed by running npm install -g standard (nodejs is required). No more configuration needed. More information about the style guide can be found here: http://standardjs.com/.
ESlint for Javascript. http://eslint.org/ It can be installed by running npm install eslint for a local project or by running npm install -g eslint for global use. The linter is then installed locally at $YOUR_PROJECT/node_modules/.bin/eslint or globally at ~/.npm-global/bin/eslint. When running the formatter, vim will walk up from the current file to search for such local installation and a ESLint configuration file (either .eslintrc.js or eslintrc.json). When the local version is missing it will fallback to the global version in your home directory. When both requirements are found eslint is executed with the --fix argument. Note that the formatter's name is still eslint_local for legacy reasons even though it already supports global eslint. Currently only working on *nix like OS (Linux, MacOS etc.) as it requires the OS to provide sh like shell syntax.
xo for Javascript. It can be installed by running npm install -g xo (nodejs is required). Here is the link to the repository: https://github.com/sindresorhus/xo.
html-beautify for HTML. It is shipped with js-beautify, which can be installed by running npm install -g js-beautify. Note that nodejs is needed for this to work. Here is the link to the repository: https://github.com/einars/js-beautify.
css-beautify for CSS. It is shipped with js-beautify, which can be installed by running npm install -g js-beautify. Note that nodejs is needed for this to work. Here is the link to the repository: https://github.com/einars/js-beautify.
typescript-formatter for Typescript. typescript-formatter is a thin wrapper around the TypeScript compiler services. It can be installed by running npm install -g typescript-formatter. Note that nodejs is needed for this to work. Here is the link to the repository: https://github.com/vvakame/typescript-formatter.
sass-convert for SCSS. It is shipped with sass, a CSS preprocessor written in Ruby, which can be installed by running gem install sass. Here is the link to the SASS homepage: http://sass-lang.com/.
tidy for HTML, XHTML and XML. It's probably in your distro's repository, so you can download it as a regular package. For Ubuntu type sudo apt-get install tidy in a terminal.
rbeautify for Ruby. It is shipped with ruby-beautify, which can be installed by running gem install ruby-beautify. Note that compatible ruby-beautify-0.94.0 or higher version. Here is the link to the repository: https://github.com/erniebrodeur/ruby-beautify. This beautifier developed and tested with ruby 2.0+, so you can have weird results with earlier ruby versions.
rubocop for Ruby. It can be installed by running gem install rubocop. Here is the link to the repository: https://github.com/bbatsov/rubocop
gofmt for Golang. The default golang formatting program is shipped with the golang distribution. Make sure gofmt is in your PATH (if golang is installed properly, it should be). Here is the link to the installation: https://golang.org/doc/install
rustfmt for Rust. It can be installed using cargo, the Rust package manager. Up-to-date installation instructions are on the project page: https://github.com/nrc/rustfmt/#installation.
dartfmt for Dart. Part of the Dart SDK (make sure it is on your PATH). See https://www.dartlang.org/tools/dartfmt/ for more info.
perltidy for Perl. It can be installed from CPAN cpanm Perl::Tidy . See https://metacpan.org/pod/Perl::Tidy and http://perltidy.sourceforge.net/ for more info.
stylish-haskell for Haskell It can be installed using cabal build tool. Installation instructions are available at https://github.com/jaspervdj/stylish-haskell#installation
remark for Markdown. A Javascript based markdown processor that can be installed with npm install -g remark-cli. More info is available at https://github.com/wooorm/remark.
fprettify for modern Fortran. Download from official repository. Install with ./setup.py install or ./setup.py install --user.
mix format for Elixir. mix format is included with Elixir 1.6+.
fixjson for JSON. It is a JSON file fixer/formatter for humans using (relaxed) JSON5. It fixes various failures while humans writing JSON and formats JSON codes. It can be installed with npm install -g fixjson. More info is available at https://github.com/rhysd/fixjson.
shfmt for Shell. A shell formatter written in Go supporting POSIX Shell, Bash and mksh that can be installed with go get -u mvdan.cc/sh/cmd/shfmt. See https://github.com/mvdan/sh for more info.

=== ALE
Asynchronous Linting Engine
:h ale
:ALEInfo - shows relevant info - filetype, enabled linters, and various options.
:ALEDetail - Show the full linter message for the current line (if the line has a linter message).
:ALELint - run linting on current buffer.
ALEReset, ALEResetBuffer - will remove all problems reported by ALE for all buffers or one buffer, respectively. Either command will leave ALE linting enabled, so ALE will report problems when linting is performed again.
ALEFirst, ALELast, ALEPreviousWrap, ALENextWrap - moves between warnings & errors in the buffer.
ALEToggle, ALEEnable, ALEDisable - enable or disable ALE linting
ALEToggleBuffer, ALEEnableBuffer, ALEDisableBuffer - enable or disable ALE linting for the current buffer.
ALEFix, ALEGoToDefinition, ALEGoToDefinitionInTab - promising commands, have not utilized them yetRequires the actual fixers to be installed.

==============================================================================
vim:tw=78:ts=8:ft=help:norl:

